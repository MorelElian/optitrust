open Prelude
open Target
open Resource_formula

let ro_group_split = toplevel_var "ro_group_split"
let ro_group_merge = toplevel_var "ro_group_merge"

(** This transformation turns:

    // RO(f, T) * stars_i R(i)
    pfor i
      consumes R(i)
      produces R'(i)
      seq_reads RO(?f, T)
      Instr(i)
    // T * stars_i R'(i)

  into:

    // RO(f, T) * stars_i R(i)
    ghost rewrite [dup] RO(f, T) = stars'_i RO(f/n, T)
    // stars_i RO(f/n, T) * stars_i R(i)
    pfor i
      consumes R(i) * T
      produces R'(i) * T
      Instr(i)
    // stars_i RO(f/n, T) * stars_i R'(i)
    ghost rewrite [dedup] stars_i RO(f/n, T) = RO(f, T)
    // RO(f, T) * stars_i R'(i)
*)
let parallelize_reads_on (t: trm): trm =
  Pattern.pattern_match t [
    Pattern.(trm_for !__ !__ (some !__)) (fun range body contract ->
      let inv, seq_reads = List.partition_map (fun (h, formula) ->
        match formula_read_only_inv formula with
        | Some { frac; formula } -> Right (h, frac, formula)
        | None -> Left (h, formula)
        ) contract.invariant.linear
      in
      let ghosts_before = List.map (fun (_, frac, formula) ->
        trm_ghost_rewrite (formula_read_only ~frac formula) (formula_read_only ~frac (formula_group_range range formula)) (trm_var ro_group_split)) seq_reads in
      let ghosts_after = List.map (fun (_, frac, formula) ->
        trm_ghost_rewrite (formula_read_only ~frac (formula_group_range range formula)) (formula_read_only ~frac formula) (trm_var ro_group_merge)) seq_reads in

      let contract = { contract with invariant = { contract.invariant with linear = inv };
        iter_contract = { pre = { contract.iter_contract.pre with linear = new_ro @ contract.iter_contract.pre.linear } ;
          post = { contract.iter_contract.post with linear = new_ro @ contract.iter_contract.post.linear } }
        }
      in

      trm_replace (Trm_for (range, body, Some contract)) t
    );
    Pattern.(!__) (fun _ -> failwith "Loop.parallelize_reads: This transformation can only be applied on a for loop with a contract")
  ]

let%transfo parallelize_reads (tg: target): unit =
  apply_at_target_paths parallelize_reads_on tg

let t = parallelize_reads
