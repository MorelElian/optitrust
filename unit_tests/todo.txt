- renaming 

No renaming needed:


   dune
   ast.ml
   flags.ml
   paths.ml
   aos_to_soa.ml


Suggested renamings:

   optitrust.ml/mli => optitrust.ml/mli

   print_ast.ml => ast_to_text

   clang_ast_parser.ml => ast_of_clang

   translate_ast.ml => ast_to_c

   transformations.ml => to be split in:
      - labels.ml : for insert and remove labels
      - declaration.ml : for insert_decl, remove_decl, fold_decl
      - inlining.ml : for inline_decl, inline_fun
      - transformations.ml : only generic helper functions
      - sequence.ml : for sequence reordering, create subsequence, flattening, split sequence
      - loop_swap.ml : for loop swapping

   loop_tiling => loop_tile

   array_tiling => array_tile

   swap_coordinates => array_swap_coord

   extract_loop_var.ml => loop_var_extract


- splitting of doc/transfo.cpp  unit_tests/transfo.{cpp,ml,_exp.cpp}


- doc/Makefile will have:
      
      include ../tools/Makefile.tests
      plus extra rules for building doc.html
  
  and unit_tests/Makefile does the struct_name    
     EXCLUDE_ML=foo.ml
     include   ../tools/Makefile.tests    
      but using specific definitions for EXCLUDE_ML etc..
  

 in Makefile, after merge of diff branch
DOCML=$(wildcard *_doc.ml)
doc: $(DOCML:.ml:_diff.html)


- you can "cite" the transformations from doc/*.*  in doc/doc.html

- rust and intern   porting C code to Rust   -> webassembly
    https://c2rust.com/manual/c2rust-refactor/rewrite.html

- calendar for presentations

- what's left for pic_demo
   - parallel loop in the AST, and dump it as pragma (no need to reparse it)
   - check or implement whether we can delete arbitrary lines and insert arbitrary lines
       replace path new_trm
       seq_delete_instr path = replace path "{}@nobraces"
       seq_insert_instr ~before:path ~after:path ~at_head:bool ~at_last:bool new_trm
- TODO: add also the column 
- TODO: Merge diff >> intial_transfomation && other branches into initial_transformation 
  then initial_transformation >> master

- rewriting patterns
- discuss the problem of targeting variables up to shadowing


-----
Actions triggered by shortcuts from the IDE (e.g. VScode) lead to the writing
of the command to be executed in a file called `.vscode/action.sh`.

Independently, we use a permanentenly-running process called `.vscode/watch.sh`
to watch over the file `.vscode/action.sh`. Whenever a modification is made,
the script is executed.

In VSCode, the keybinding.json file associates, e.g., F6 gets bound to the runTask action.
  {
    "key": "f6",
    "command": "workbench.action.tasks.runTask",
    "args": "Execute transformation script"
  },

and the tasks.json file associates runTask 

      {
            "label": "Execute transformation script",
            "type": "shell",
            "command": "./run_action.sh",
            "options": {
              "cwd": "${workspaceFolder}/.vscode"
            },
            "args": [
                "./add_exit_and_exec.sh",
                "${fileDirname}",
                "${fileBasenameNoExtension}",
                "${lineNumber}",
                ""
            ]
        },
        {


The run_action.sh script simply executes `cat $* >> ./action.sh`
meaning that we will get watch.sh to execute action.sh whose contents
is the first argument of `args` above applied to all the other arguments.

Run `make watch` from /src folder to launch the watch script in a terminal
independent from vscode.
---------






-----















================================================================
LATER (nor urgent): add tests for combined transformations:
- insert_and_fold
- split_loop
- insert_and_fold_typedef

TODO BEGATIM: add unit tests for testing insertion of declaration of:
- type definitions
- const definitions
- variable definitions
- arbitrary code
 (at a specified location, e.g. just before or after another specific definition)
// insert_decl, insert_const, insert_typedef


